import methodOverride from 'method-override';
import express from 'express';
import {
  read, add, deleteContent, edit,
} from './jsonFileStorage.js';

const app = express();
const PORT = 3000;
const FILENAME = 'data.json';

// Set view engine to EJS
app.set('view engine', 'ejs');
// Middleware to allow static images/css files to be served
app.use(express.static('public'));
// Provides encoding to url queries etc.
app.use(express.urlencoded({ extended: false }));
// Middleware that allows POST methods to be overriden to perform PUT and DELETE requests
app.use(methodOverride('_method'));

// Helper Function that converts request.body to an Iterable Obj
const convertToIterableObj = (nonIterableObj) => {
  const newObj = {};
  // Convert request.body into an iterable object
  Object.entries(nonIterableObj).forEach(([key, value]) => {
    newObj[key] = value;
  });
  return newObj;
};

// Helper Function that checks the inputs for validation
const performValidationOnRequestBody = (requestBodyObj, callback) => {
  const inputValidationFeedbackObj = {};
  let isFormValid = true;
  const {
    _, description, date_time, city, state, shape, duration, summary, __,
  } = requestBodyObj;

  if (description.length < 5) {
    inputValidationFeedbackObj.description = 'Description is too short!';
    isFormValid = false;
  } else {
    inputValidationFeedbackObj.description = 'ok';
  }

  if (shape.toLowerCase() !== 'sphere' && shape.toLowerCase() !== 'circle') {
    inputValidationFeedbackObj.shape = 'Shape is not valid.';
    isFormValid = false;
  } else {
    inputValidationFeedbackObj.shape = 'ok';
  }
  callback(inputValidationFeedbackObj, isFormValid);
};

// Route: Homepage - Shows all sightings, sortable by ID
app.get('/', (request, response) => {
  const orderOfSort = request.query.sortOrder;
  read(FILENAME, (data, error) => {
    if (error) {
      response.sendStatus(500, error);
      return;
    }
    data.sightings.sort((a, b) => {
      if (orderOfSort === 'ascending') {
        return a.id - b.id;
      } if (orderOfSort === 'descending') {
        return b.id - a.id;
      }
      return a.id - b.id;
    });
    response.render('allSightings', data);
  });
});

// Route: Create form to input sighting
app.get('/newSighting', (request, response) => {
  read(FILENAME, (data, error) => {
    if (error) {
      response.sendStatus(500, error);
      return;
    }
    response.render('submitNewSightingForm', data);
  });
});

// Create a POST method / request to submit new sighting
app.post('/newSighting', (request, response) => {
  const requestBodyObj = convertToIterableObj(request.body);
  // locally scoped boolean to track if current form is valid
  let isThisFormValid = true;

  // Perform input validation first
  performValidationOnRequestBody(requestBodyObj, (feedbackMsg, areFieldsValid) => {
    if (areFieldsValid === false) {
      request.body.feedback = feedbackMsg;
      isThisFormValid = false;
      response.render('submitNewSightingForm', request.body);
    }
  });
  if (isThisFormValid === false) {
    return;
  }

  /**
   * @param {FILENAME} contains all the data of the sightings to be read
   * @param {key} the key to access in the file to be added
   * @param {input} in this case, it is the iterated requestBodyObj
   * @param {callback} performs a callback after taking in the data and error vars from add fn
  */
  add(FILENAME, 'sightings', requestBodyObj, (data, error) => {
    // to be redirected to sighting/<index>
    response.redirect(`/sighting/${data.sightings.length}`);
  });
});

// Route: Render a particular sighting
app.get('/sighting/:id', (request, response) => {
  // id of sighting is not zero-indexed
  const { id } = request.params;
  read(FILENAME, (data) => {
    const sightingData = data.sightings[id - 1];
    response.render('sighting', sightingData);
  });
});

// Render a form to edit a sighting
app.get('/sighting/:id/edit', (request, response) => {
  // id of sighting is not zero-indexed
  const { id } = request.params;
  read(FILENAME, (data) => {
    const sightingData = data.sightings[id - 1];
    response.render('editExistingSightingForm', sightingData);
  });
});

// Edit the sighting through a PUT method
app.put('/sighting/:id/edit', (request, response) => {
  // id of sighting is not zero-indexed
  const { id } = request.params;
  const requestBodyObj = convertToIterableObj(request.body);

  // locally scoped boolean to track if current form is valid
  let isThisFormValid = true;

  // Perform input validation first
  performValidationOnRequestBody(requestBodyObj, (feedbackMsg, areFieldsValid) => {
    if (areFieldsValid === false) {
      // Assigning feedback & id from helper function into request.body
      request.body.feedback = feedbackMsg;
      // Note that request.body generated by all the forms does not include id automatically,
      // hence the inclusion
      request.body.id = id;
      isThisFormValid = false;
      response.render('sightingFormEdit', request.body);
    }
  });
  if (isThisFormValid === false) {
    return;
  }
  /**
 * @param {FILENAME} some file to be read
 * @param {id} the corresponding id of the sighting
 * @param {input} in this case, it is the iteratable requestBodyObj
 * @param {callback} performs a callback after taking in the data and error vars from add fn
*/
  edit(FILENAME, id, requestBodyObj, (data, error) => {
    if (error) {
      response.sendStatus(500, 'error');
      return;
    }
    response.redirect(`/sighting/${data.sightings.length}`);
  });
});

// Render a list of all sighting shapes
app.get('/shapes', (request, response) => {
  read(FILENAME, (data) => {
    response.render('allShapes', data);
  });
});

// Render sighting based on a shape
app.get('/shapes/:shape', (request, response) => {
  const { shape: selectedShape } = request.params;
  read(FILENAME, (data) => {
    // Declare an object that stores the desired shape, followed by corresponding sighting
    const selectedShapeSightings = { sightings: [], shape: '' };
    selectedShapeSightings.shape = selectedShape;
    // Filter by shape and stores all the associated sighting(s)
    // into an sightings key/variable within selectedShapeSightings obj
    selectedShapeSightings.sightings = data.sightings.filter((sighting) => sighting.shape === selectedShape);
    response.render('shape', selectedShapeSightings);
  });
});

// Accept a request to delete a sighting
app.delete('/sighting/:id/', (request, response) => {
  const { id } = request.params;
  deleteContent(FILENAME, id, (data, error) => {
    if (error) {
      response.sendStatus(500, 'error');
      return;
    }
    response.redirect('/');
  });
});

app.listen(PORT);
